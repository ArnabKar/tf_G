% !TEX root = ../../document.tex

\documentclass{subfiles}

\begin{document}

  \chapter{Algoritmos para Streaming}
  \label{chapter:streaming}


    \section{Introducción}
    \label{sec:streaming_intro}

      \paragraph{}
      En este capítulo se trata de realizar una descripción en profundidad acerca de los \emph{Algoritmos en Streaming} desde una perspectiva tanto a teórica como práctica. Para ello se describirá el modelo de cómputo en que se enmarcan dichos algoritmos (Modelo en Streaming) en la sección \ref{sec:streaming_model} además de su estructura básica en la sección \ref{sec:streaming_structure}. El motivo de dicha descripción se debe a que los \emph{Algoritmos para Streaming} presentan un conjunto de peculiaridades respecto de la gran mayoría de algoritmos utilizados comunmente. [TODO introducir el resto de secciones]

      \paragraph{}
      Para realizar una primera aproximación acerca de en qué consiste esta categoría algorítmica es necesario realizar una diferenciación entre distintos conceptos relacionados con ella, que pueden producir confusiones debido a su similitud o abusos previos del lenguaje. Por lo tanto, a continuación se describen conceptos relacionados con los \emph{Algoritmos en Streaming} que permitirán introducir al lector en el contexto del problema. Además, se realiza una diferenciación acerca de los factores que se pretenden optimizar a partir de esta estrategia de diseño de algoritmos.


      \subsection{Computación en Tiempo Real}
      \label{sec:realtime_computing}
        \paragraph{}
        El primer concepto que se describe es \textbf{Computación en Tiempo Real}, que tal y cómo describen Shin y Ramanathan \cite{259423} se carácteriza por tres términos que se describen a continuación:

        \begin{itemize}

          \item \textbf{Tiempo}\emph{(time)}: En la disciplina de \emph{Computación en Tiempo Real} el tiempo de ejecucción de una determinada tarea es especialmente crucial para garantizar el correcto desarrollo del cómputo, debido a que se asume un plazo de ejecucción permitido, a partir del cual la solución del problema deja de tener un valor óptimo. Shin y Ramanathan\cite{259423} diferencian entre tres categorías dentro de dicha restricción, a las cuales denominan \emph{hard}, \emph{firm} y \emph{soft}, dependiendo del grado de relajación de la misma.

          \item \textbf{Confiabilidad}\emph{(correctness)}: Otro de los puntos cruciales en un sistema de \emph{Cómputación en Tiempo Real} es la determinación de una unidad de medida o indicador acerca de las garantias de una determinada solución algorítmica para cumplir lo que promete de manera correcta en el tiempo esperado.

          \item \textbf{Entorno}\emph{(environment)}: El último factor que indican Shin y Ramanathan\cite{259423} para describir un sistema de \emph{Computación en Tiempo Real} es el entorno del mismo, debido a que este condiciona el conjunto de tareas y la periodicidad en que se deben llevar a cabo. Debido a esta razón, realizan una diferenciación entre:
          \begin{enumerate*}[label=\itshape\alph*\upshape)]
  					\item tareas periódicas \emph{periodic tasks} las cuales se realizan secuencialmente a partir de la finalización de una ventana de tiempo, y
  					\item tareas no periódicas \emph{periodic tasks} que se llevan a cabo debido al suceso de un determinado evento externo.
  				\end{enumerate*}

        \end{itemize}


      \subsection{Problemas Dinámicos}
      \label{sec:dynamic_problems}

        \paragraph{}
        Una vez completada la descripción acerca de lo que se puede definir como \emph{Computación en Tiempo Real}, conviene realizar una descripción desde el punto de vista de la \emph{teoría de complejidad computacional}. Para definir este tipo de problemas, se utiliza el término \emph{problemas dinámicos}, los cuales consisten en aquellos en los cuales es necesario recalcular su solución conforme el tiempo avanza debido a variaciones en los parámetros de entrada del problema (Nótese que dicho término no debe confundirse con la estrategia de \emph{programación dinámica} para el diseño de algoritmos).

        \paragraph{}
        Existen distintas vertientes dependiendo del punto de vista desde el que se estudien, tanto de la naturaleza del problema (soluciones dependientes temporalmente unas de otras o soluciones aisladas) como de los parámetros de entrada (entrada completa en cada nueva ejecución o variación respecto de la anterior). Los \emph{Algoritmos para Streaming} están diseñados para resolver \emph{problemas dinámicos}, por lo que en la sección \ref{sec:streaming_model}, se describe en profundidad el modelo en que se enmarcan.

        \paragraph{}
        A continuación se indican los principales indicadores utilizados para describir la complejidad de una determinada solución algorítmica destinada a resolver un problema de dicha naturaleza:

        \begin{itemize}
          \item Espacio: Cantidad de espacio utilizado en memoria durante la ejecución del algoritmo.
          \item Inicialización: Tiempo necesario para la inicialización del algoritmo.
          \item Procesado: Tiempo necesario para procesar una determinada entrada.
          \item Pregunta[TODO Buscar mejor palabra]: Tiempo necesario para procesar la solución a partir de los datos de entrada procesados hasta el momento.
        \end{itemize}


      \subsection{Algoritmos Online vs Algoritmos Offline}

        \paragraph{}
        Una vez descrita la problemática de \emph{Computación en Tiempo Real} en la sección \ref{sec:realtime_computing} y la categoría de \emph{Problemas Dinámicos} en la sección \ref{sec:dynamic_problems}, en esta sección se pretende ilustrar la diferencia entre los \emph{Algoritmos Online} y los \emph{Algoritmos Offline}. Para ello, se ha seguido la diferenciación propuesta por Karp \cite{Karp:1992:OAV:645569.659725}, en la cual se plantea el problema de la siguiente manera (Se utilizará la misma notación que sigue Muthukrishnan\cite{Muthukrishnan:2005:DSA:1166409.1166410} para tratar mantener la consistencia durante todo el documento): Sea $A$ el conjunto de datos o eventos de entrada, siendo cada $A[i]$ el elemento \emph{i-ésimo} del conjunto. En el caso de los \emph{Algoritmos Online} supondremos que es el elemento recibido en el instante \emph{i}. A continuación se muestran las características de cada subgrupo:

        \begin{itemize}
          \item \textbf{Algoritmos Offline}: Esta categoría contiene todos los algoritmos que realizan el cómputo suponiendo el acceso a cualquier elemento del conjunto de datos $A$ durante cualquier momento de su ejecución. Además, en esta categoría se impore la restricción de que el $A$ debe ser invariante respecto del tiempo, lo que impone que para la adaptación del resultado a cambios, este tenga que realizar una nueva ejecución desde su estado inicial. Nótese que por tanto, dentro de este grupo se engloba la mayoría de algoritmos utilizados comunmente.

          \item \textbf{Algoritmos Online}: Son aquellos que calculan el resultado a partir de una secuencia de sucesos $A[i]$, los cuales generan un resultado dependiente del valor, y posiblemente de los sucedidos anteriormente. A partir de dicha estrategia, se añade una componente dinámica, la cual permite que tamaño del conjunto de datos de entrada $A$ no tenga impuesta una restricción acerca de su longitud. Por contra, en este modelo no se permite conocer el cuceso $A[i+1]$ en el momento $i$.  Esto encaja perfectamente en el modelo que se describirá en la sección \ref{sec:streaming_model}.

        \end{itemize}

        \paragraph{}
        Según la diferenciación que se acaba de describir, estas dos estrategias de diseño de algoritmos encajan en disciplinas distintas de diseño de algoritmos, teniendo una gran ventaja a nivel de eficiencia en el caso estático los \emph{Algoritmos Offline}, pero quedando prácticamente inutilizables cuando la computación es en tiempo real, donde es mucho más apropiado el uso de estrategias de diseño de \emph{Algoritmos Online}.

        \paragraph{}
        Como medida de eficiencia para los \emph{Algoritmos Online}, Karp \cite{Karp:1992:OAV:645569.659725} propone el \textbf{Ratio Competitivo}, el cual se define como la cota inferior del coste de cualquier nueva entrada con respecto de la que tiene menor coste. Sin embargo, dicha medida de eficiencia no es comúnmente utilizada en el caso de los \emph{Algoritmos para Streaming} por la componente estocástica de los mismos, para los cuales son más apropiadas medidas probabilistas. A continuación se describen las ventajas de estos respecto de su vertiente estática.


      \subsection{Algoritmos Probabilistas}

        \paragraph{}
        Los \emph{Algoritmos Probabilistas} son una estrategia de diseño que emplea en un cierto grado de aleatoriedad en alguna parte de su lógica. Estos utilizan distribuciones uniformes de probabilidad para tratar de conseguir un incremento del rendimiento en su caso promedio. A continuación se describen los dos tipos de algoritmos probabilísticos según la clasificación realizada por Babai \cite{Babai79monte-carloalgorithms}:

        \begin{itemize}

          \item \textbf{Algoritmos Las Vegas}: Devuelven un resultado incorrecto con una determinada probabilidad, pero avisan del resultado incorrecto cuando esto sucede. Para contrarrestrar este suceso basta llevar a cabo una nueva ejecución del algoritmo, lo cual tras un número indeterminado de ejecuciones produce un resultado válido.

          \item \textbf{Algoritmos Monte Carlo}: Fallan con un cierto grado de probabilidad, pero en este caso no avisan del resultado incorrecto. Por lo tando, lo único que se puede obtener al respecto es una indicador de la estimación del resultado correcto hacia la que converge tras varias ejecuciones. Además, se asegura una determinada cota del error $\epsilon$, que se cumple con probabilidad $\delta$.

        \end{itemize}

        \paragraph{}
        La razón anecdótica por la cual Babai \cite{Babai79monte-carloalgorithms} decidió denominar dichas categorías de algoritmos de esta manera se debe a lo siguiente (teniendo en cuenta el contexto de lengua inglesa): cuando se va a un casino en \emph{Las Vegas} y se realiza una apuesta el \emph{croupier} puede decir si se ha ganado o perdido porque habla el mismo idioma. Sin embargo, si sucede la misma situación en \emph{Monte Carlo}, tan solo se puede conocer una medida de probabilidad debido a que en este caso el \emph{croupier} no puede comunicarlo por la diferencia dialéctica.


      \subsection{Algoritmos Online Probabilistas vs Deterministas}

        \paragraph{}
        La idea subyacente acerca del diseño de los \emph{Algoritmos Online} es la mejora de eficiencia con respecto a sus homónimos estáticos cuando el conjunto de valores de entrada es dependiente de los resultados anteriores. Sin embargo, existen casos en que la frecuencia de ejecución del algoritmo, debido a una alta tasa de llegada de sucesos de entrada, las soluciones deterministas se convierten en alternativas poco escalables.

        \paragraph{}
        Dicha problemática se ha incrementado de manera exponencial debido al avance tecnológico y la gran cantidad de información que se está generando en la actualidad. Este fenómeno ha convertido en algo necesario el diseño de estrategias basadas en sucesos probabilísticos que reduzcen en gran medida el coste computacional eliminando el determinismo de la solución.


    \section{Modelo en Streaming}
    \label{sec:streaming_model}

      \paragraph{}
      En esta sección se describen los aspectos formales del \emph{Modelo en Streaming}. Para ello se ha seguido la representación definida por Muthukrishnan \cite{Muthukrishnan:2005:DSA:1166409.1166410}. Lo primero por tanto, es definir lo que es un flujo de datos o \emph{Data Stream} como una \say{secuencia de señales digitalmente codificadas utilizadas para representar una transmisión de información} \cite{ITS-def-data-stream}. Muthukrishnan \cite{Muthukrishnan:2005:DSA:1166409.1166410} hace una aclaración sobre dicha definición y añade la objeción de que los datos de entrada deben tener un ritmo elevado de llegada. Debido a esta razón existe complejidad a tres niveles:

      \begin{itemize}

        \item \textbf{Transmisión}: Ya que debido a la alta tasa de llegada es necesario diseñar un sistema de interconexiones que permita que no se produzcan congestiones debido a la obtención de los datos de entrada.

        \item \textbf{Computación}: Puesto que la tarea de procesar la gran cantidad de información que llega por unidad de tiempo produce cuellos de botella en el planteamiento. Por lo que es necesario implementar técnicas algorítmicas con un reducido nivel de complejidad computacional que para contrarrestar dicha problemática.

        \item \textbf{Almacenamiento}: Debido a la gran cantidad de datos que se presentan en la entrada, deben existir técnicas que permitan almacenar dicha información de manera eficiente. Esto puede ser visto desde dos puntos de vista diferences: \begin{enumerate*}[label=\itshape\alph*\upshape)]
          \item tanto desde el punto de vista del espacio, tratando de minimizar el tamaño de los datos almacenados, maximizando la cantidad de información que se puede recuperar de ellos,
          \item como desde el punto de vista del tiempo necesario para realizar operaciones de búsqueda, addición, eliminación o edición.
        \end{enumerate*}

      \end{itemize}

      \paragraph{}
      [TODO ejemplo de los tres niveles de complejidad a partir del análisis meteorológico ]

      \subsection{Formalismo para Streaming}
      \label{sec:streaming_formalism}

        \paragraph{}
        Una vez descritos los niveles de complejidad a los que es necesario hacer frente para abordar problemas en el \emph{Modelo en Streaming}, se realiza una descripción de los distintos modelos que propone Muthukrishnan \cite{Muthukrishnan:2005:DSA:1166409.1166410} en los apartados \ref{sec:streaming_time_series}, \ref{sec:streaming_cash_register} y \ref{sec:streaming_turnstile}. La especificación descrita en dichos apartados será seguida durante el resto del capítulo. Para ello nos basaremos en el siguiente formalismo:

        \paragraph{}
        Sea $a_1 ,a_2 ,... ,a_t,... $ un flujo de datos de entrada (\emph{Input Stream}), de tal manera que cada elemento debe presentar un orden de llegada secuencial respecto de $t \in \mathbb{N}$. Esto también se puede ver de la siguiente manera: el elemento siguiente a la llegada de $a_{t-1}$ debe ser $a_{t}$ y, por inducción, el próximo será $a_{t+1}$. Es necesario aclarar que $t$ no se refiere a unidades propiamente temporales, sino a la posición en la entrada.


        \begin{equation}
        \label{eq:streaming_A_function}
          \boldsymbol{A}_t:[1...N] \rightarrow \mathbb{R}^2
        \end{equation}


        \paragraph{}
        El siguiente paso para describir el formalismo es añadir la función $\boldsymbol{A}_t$, cuyo dominio e imagen se muestran en la ecuación \eqref{eq:streaming_A_function}. Esta función tiene distintas interpretaciones dependientes del \emph{Modelo en Streaming} con el cual se esté tratando en cada caso, pero la idea subyacente se puede resumirse asumiendo que la primera componente almacena el valor, mientras que la segunda almacena el número de ocurrencias de dicho valor. Algo común a todos ellos es la variable $t$, que se corresponde con resultado de la función en el instante de tiempo $t$. Por motivos de claridad, en los casos en que nos estemos refiriendo un único momento, dicha variable será obviada en la notación.

      \subsection{Modelo de Serie Temporal}
      \label{sec:streaming_time_series}

        \paragraph{}
        El \emph{Modelo de Serie Temporal} o \emph{Time Series Model} se refiere, tal y como indica su nombre, a una serie temporal, es decir, modeliza los valores que toma la variable $i$ respecto de $t$, codificados en el modelo como $a_t = (i,1)$. Nótese que se utiliza el valor $1$ en la segunda componente de $a_t$, la razón de ello se debe a la definición de la imagen de $\boldsymbol{A}$ en la ecuación \eqref{eq:streaming_A_function}. A pesar de ello, dicho campo es irrelevante en este modelo, por lo que se podría haber escogido cualquier otro arbitrariamente. La razón por la cual se ha utilizado el valor $1$ ha sido el refuerzo de la idea de que en este caso, el valor que toma la $a_t$ en un determinado momento, no volverá a variar su valor, pero quedará obsoleto con la llegada de $a_{t+1}$.

        \paragraph{}
        El modelo se describe de manera matemática mediante la función $\boldsymbol{A}$, tal y como se ilustra en la ecuación \eqref{eq:streaming_time_series}. Textualmente, esto puede traducirse diciendo que la función $\boldsymbol{A}$ representa una estructura de datos que almacena el valor de todos los elementos recibidos en la entrada hasta el instante de tiempo $t$, es decir, actúa como un historial. Un ejemplo de este modelo son los valores en bolsa que toma una determinada empresa a lo largo del tiempo.

        \begin{equation}
  			\label{eq:streaming_time_series}
  				\boldsymbol{A}(t) = a_t
  			\end{equation}

      \subsection{Modelo de Caja Registradora}
      \label{sec:streaming_cash_register}

        \paragraph{}
        El \emph{Modelo de Caja Registradora} o \emph{Cash Register Model} consiste en la recepción de incrementos de un determinado valor $i$. El nombre del modelo hace referencia al funcionamiento de una caja registradora (suponiendo que el pago se realiza de manera exacta), que recibe billetes o monedas de tipos diferentes de manera secuencial.

        \paragraph{}
        Para describir dicho modelo, previamente hay que realizar una aclaración acerca del contenido del elemento $a_t = (i, I_t)$, de manera que $i$ representa el valor recibido, mientras que $I_t \geq 0$ indica el incremento en el instante $t$. Una vez aclarada esta definición, la función $\boldsymbol{A}_{t}$, se construye tal y como se indica en la ecuación \eqref{eq:streaming_cash_register}.

        \begin{equation}
  			\label{eq:streaming_cash_register}
  				\boldsymbol{A}_{t}(i) = {A}_{t-1}(i) + I_{t}
  			\end{equation}

        \paragraph{}
        El \emph{Modelo de Caja Registradora} es ampliamente utilizado en la formalización de problemas reales debido a que muchos fenómenos siguen esta estructura. Un ejemplo de ello es el conteo de accesos a un determinado sitio web, los cuales se corresponden con incrementos $I_t$, en este caso de caracter unitario realizados por un determinado usuario $i$ en el momento $t$.


      \subsection{Modelo de Molinete}
      \label{sec:streaming_turnstile}

        \paragraph{}
        El \emph{Modelo de Molinete} o \emph{Turnstile Model} se corresponde con el caso más general, en el cual no solo se permiten incrementos, sino que también se pueden realizar decrementos en la cuenta. El nombre que se le dió a este modelo se debe al funcionamiento de los molinetes que hay en las estaciones de metro para permitir el paso a los usuarios, que en la entrada incrementan la cuenta del número de personas, mientras que en la salida los decrementan. La relajación originada por la capacidad de decremento ofrece una mayor versatilidad, que permite la contextualización de un gran número de problemas en este modelo. Por contra, añade un numerosas complicaciones a nivel computacional, tal y como se verá a lo largo del capítulo.

        \paragraph{}
        Tal y como ocurre en el caso anterior, para describir este modelo, lo primero es pensar en la estructura de los elementos en la entrada, que están formados por $a_t = (i, U_t)$, algo muy semejante a lo descrito en el \emph{Modelo de Caja Registradora}. Sin embargo, en este caso $U_t$ no tiene restricciones en su imagen, sino que puede tomar cualquier valor tanto positivo como negativo, lo cual añade el concepto de decremento. La construcción de la función $\boldsymbol{A}_{t}$ se describe en la ecuación \eqref{eq:streaming_turnstile}.

        \begin{equation}
        \label{eq:streaming_turnstile}
          \boldsymbol{A}_{t}(i) = {A}_{t-1}(i) + U_{t}
        \end{equation}

        \paragraph{}
        Muthukrishnan \cite{Muthukrishnan:2005:DSA:1166409.1166410} hace una diferenciación dentro de este modelo dependiendo del nivel de exigencia que se le pide al modelo, se dice que es un \emph{Modelo de Molinete estricto} cuando se añade la restricción $\forall i, \forall t \ \boldsymbol{A}_{t}(i) \geq 0$, mientras que se dice que es un \emph{Modelo de Molinete relajado} cuando dicha restricción no se tiene en cuenta.

        \paragraph{}
        Un ejemplo de este modelo es el conteo del número de usuarios que están visitando un determinado sitio web, tomando $U_t$ el valor $1$ en el caso de una nueva conexión y $-1$ en el caso de de una desconexión. En este ejemplo el valor $i$ representa una determinada página dentro del sitio web.

    \section{Estructura básica}
    \label{sec:streaming_structure}

      \paragraph{}
      Puesto que la naturaleza intríseca de los \emph{Algoritmos para Streaming} hace que procesen los elementos de entrada según van llegando, esto presenta peculiaridades con respecto a otras categorías algorítmicas utilizadas comúnmente. Por tanto, primero se describirá la estructura básica que siguen los algoritmos más comunmente utilizados para después mostrar la estrategia seguida en el caso de Streaming.

      \paragraph{}
      Los algorítmos clásicamente estudiados para resolver la mayoría de problemas se basan la idea de funciones matemáticas. Es decir, se les presenta un conjunto de valores en la entrada, y a partir de ellos, realizan una determinada transformación sobre ellos, que genera como resultado una determinada salida. Nótese que esta idea no genera ninguna restricción acerca de lo que puede suceder en dicho proceso, es decir, no se restringe el uso de estructuras de datos auxiliares o técnicas similares.

      \paragraph{}
      Esta visión no se enmarca correctamente en el contexto de los \emph{Algoritmos para Streaming}. La razón se debe a que la entrada no es propiamente un conjunto de datos, sino que se refiere a un flujo en sí mismo. Esta característica conlleva que en un gran número de ocasiones ya no sea necesario obtener los resultados tras cada llamada al algoritmo, ya que estos podrían carecer de interés o requerir un sobrecoste innecesario. Por lo tanto, el concepto de función matemática pierde el sentido en este caso, ya que estas exigen la existencia de un valor como resultado.

      \paragraph{}
      Un concepto más acertado para modelizar un \emph{Algoritmo para Streaming} podría ser lo que en los lenguajes de programación derivados de \emph{Fortran} se denomina subrutina, es decir, una secuencia de instrucciones que realizan una tarea encapsulada como una unidad. Sin embargo, para poder describir correctamente la estructura de un \emph{Algoritmo para Streaming} hace falta algo más. La razón de ello es que a partir de dicho modelo de diseño no sería posible realizar peticiones acerca de lo calculado, es decir, sería una estrategia puramente procedural. Para corregir dicha problemática surge el concepto de \emph{query} o pregunta. A través de dicha idea se pretende representar la manera de obtener un resultado a partir del cómputo realizado hasta el momento actual.

      \paragraph{}
      En resumen, con dicha estrategia de diseño se consigue separar la parte de procesado de la entrada con la parte de consulta del resultado, lo cual proporciona amplias ventajas para el modelo seguido por los \emph{Algoritmos para Streaming}. Sin embargo, dicha estrategia produce un sobrecoste espacial con respecto del modelo de algoritmo clásico. Este se debe a la necesidad de mantener una estructura de datos en la cual se almacenen los resultados parciales referentes al flujo de entrada.

      \paragraph{}
      Los algoritmos \emph{Algoritmos para Streaming} se componen por tanto de algoritmo de procesamiento del flujo de datos, una estructura de datos que almacena dichos resultados, y por último, un algoritmo de procesamiento de la \emph{query} o pregunta necesaria para obtener los resultados requeridos. a continuación se dividen las fases para el funcionamiento de un algoritmo de dichas caraterísticas.

      \begin{itemize}

        \item \textbf{Inicialización}: En esta fase se llevan a cabo el conjunto de tareas necesarias para inicializar la estructura de datos que actuará como almacen de información durante el procesamiento del flujo de datos de entrada. Generalmente esto consite en el proceso de reservar memoria, inicializar a un valor por defecto la estructura de datos, etc. Sin embargo, existen técnicas sofisticadas que requieren de una mayor carga computacional en esta fase.

        \item \textbf{Procesado}: Se corresponde con el procesamiento del flujo de datos de manera secuencial. La idea subyacente en esta fase es la de realizar una determinada operación sobre la estructura de datos y el elemento de entrada actual, de manera que se lleve a cabo una actualización sobre la misma. Nótese en que la manera en que se manipula dicha estructura de datos condiciona en gran medida el conjunto de peticiones que se podrán realizar sobre ella.

        \item \textbf{Petición}: La fase de petición se caracteriza con respecto de la anterior por ser de carácter consultivo. Con esto nos estamos refiriendo a que dicha tarea no modifica el estado actual de la estructura de datos, sino que recoge información de la misma, que posiblemente transforme mediante alguna operación, para despues obtener un valor como resultado de dicha petición.

      \end{itemize}

    \section{Medidas de Análisis}
    \label{sec:streaming_analysis}

      \paragraph{}
      Los \emph{Algoritmos para Streaming} se caracterizan por utilizar soluciones estadísticas en alguna parte (generalmente en el procesado) de su cómputo para obtener la solución con un menor coste computacional. En este caso, el coste que se pretende minimizar es el referido al espacio necesario para almacenar la estructura de datos auxiliar. Tal y como se ha dicho anteriormente, la razón de ello es debida a que se presupone un conjunto masivo de datos en la entrada, por lo que se pretende que el orden de complejidad espacial respecto de la misma sea de carácter sublinear ($o(N)$).

      \paragraph{}
      El objetivo es encontrar soluciones con un índice de error acotado que permitan llegar a la solución en un orden espacial de complejidad logarítmica ($O(log(N))$). Sin embargo, existen ocasiones en que no es posible llegar a una solución en dicho orden de complejidad, como es el caso de \emph{Algoritmos para Streaming} aplicados a problemas de \emph{Grafos}, en los cuales se relaja dicha restricción a un orden de complejiddad \emph{poli-logarítmico} ($O(polylog(N))$).

      \paragraph{}
      El órden de complejidad \emph{poli-logarítmico} engloba el conjunto de funciones cuyo orden de complejidad presenta un crecimiento acorde a una función polinomial formada logaritmos. Matemáticamente esto se modeliza a través de la ecuación \eqref{eq:polylog-complexity}

      \begin{equation}
      \label{eq:polylog-complexity}
        a_{k}\log ^{k}(N)+\cdots +a_{1}\log(N)+a_{0} = O(polylog(N)) \in o(N).
      \end{equation}

      \paragraph{}
      En esta sección se muestran distintas estrategias para poder llevar a cabo la demostración de pertenencia a un determinado orden de complejidad de un \emph{Algoritmo para Streaming}. Debido a la elevada base estadística que requieren dichas demostraciones, a continuación se definen algunos conceptos básicos en relacionadas con estimadores estadísticos, para después realizar una breve demostración acerca de distintas cotas de concentración de valores en una distribución en las subsecciones \ref{sec:markov_inequality}, \ref{sec:chebyshev_inequality} y \ref{sec:chernoff_inequality}. Las definiciones que se exponen a continuación han sido extraidas de los apuntes del curso sobre \emph{Randomized Algorithms} \cite{aspnes2014notes} impartido por Aspnes en la \emph{Universidad de Yale} así como las de la asignatura de \emph{Estadística}\cite{estadistica2016notes} impartida en el Grado de Ingeniería Informática de la \emph{Universidad de Valladolid}.

      \subsection{Conceptos básicos de Estadística}
      \label{sec:basic_statistics}

        \paragraph{}
        Denotaremos como $x_1$ a una observación cualquiera contenida en el espacio de todas los posibles. Al conjunto de todas las observaciones posibles lo denotaremos como $\Omega$ y lo denominaremos espacio muestral, por lo tanto, $x \in \Omega$. Este concepto se puede entender de manera más sencilla mediante el siguiente ejemplo. Supongamos el lanzamiento de una moneda, que como resultado puede tomar los valores cara o cruz. Definiremos entonces $x_1 = \text{cara}$ y $x_2 = \text{cruz}$ como los sucesos posibles de lanzar una moneda. Por tanto el espacio $\Omega$ se define como $\Omega = \{x_1, x_2\} = \{\text{cara}, \text{cruz}\}$.

        \paragraph{}
        El siguiente paso es definir el concepto de \textbf{Variable Aleatoria}, que representa una función que mapea la realización de un determinado suceso sobre el espacio $\Omega$. Dicha función se denota con letras mayúsculas y puesto que sus parámetros de entrada son desconocidos, estos se ignoran en la notación. Por tanto denotaremos las variables aleatorias como ($\boldsymbol{E}, \boldsymbol{X}, \boldsymbol{Y}, \text{etc.}$). Para la variable aleatoria $\boldsymbol{X}$, sean $x_1, x_2, ..., x_i,...$ cada una de las observaciones posibles. Siguiendo el ejemplo anterior, se puede modelizar el lanzamiento de una moneda como $X$. Nótese por tanto, que una variable aleatoria puede definirse de manera textual como la modelización del resultado de un suceso a priori desconocido.

        \paragraph{}
        Definiremos probabilidad como la medida de certidumbre asociada a un suceso o evento futuro, expresada como un valor contenido en el intervalo $[0,1]$, tomando el valor $0$ un suceso imposible y $1$ un suceso seguro. La notación seguida para representar esto será $Pr[\boldsymbol{X} = x_i]$. Suponiendo la equiprobabilidad en el ejemplo de la moneda, podemos definir sus valores de probabilidad como $Pr[\boldsymbol{X} = \text{cara}] = \tfrac{1}{2}$ y $Pr[\boldsymbol{X} = \text{cruz}] = \tfrac{1}{2}$

        \paragraph{}
        Una vez descritos estos conceptos simples, a continuación hablaremos sobre distintos conceptos estadísticos utilizados en el análisis de algorítmos probabilisticos tales como \emph{Esperanza}, \emph{Varianza}, \emph{Variables Independientes} y \emph{Probabilidad Condicionada}.

        \paragraph{}
        Denominaremos \textbf{Esperanza Matemática} al valor medio o más probable que se espera que tome una determinada variable aleatoria. La modelización matemática de dicho concepto se muestra en la ecuación \eqref{eq:expectation}. Además, la esperanza matemática es de carácter lineal, por lo que se cumplen las ecuaciones \eqref{eq:expectation_l1} y \eqref{eq:expectation_l2}

        \begin{equation}
        \label{eq:expectation}
          \mathbb{E}[\boldsymbol{X}] = \sum_{i=1}^\infty x_i \cdot Pr[\boldsymbol{X} = x_i]
        \end{equation}

        \begin{equation}
        \label{eq:expectation_l1}
          \mathbb{E}[c\boldsymbol{X}] = c \mathbb{E}[\boldsymbol{X}]
        \end{equation}

        \begin{equation}
        \label{eq:expectation_l2}
          \mathbb{E}[\boldsymbol{X} + \boldsymbol{Y}] = \mathbb{E}[\boldsymbol{X}] + \mathbb{E}[\boldsymbol{Y}]
        \end{equation}

        \paragraph{}
        La \textbf{Varianza} se define como una medida de dispersión de una variable aleatoria. Dicho estimador representa el error cuadrático respecto de la esperanza. Su modelización matemática se muestra en la ecuación \eqref{eq:variance}. Aplicando propiedades algebraicas se puede demostrar la veracidad de las propiedades descritas en las ecuaciones \eqref{eq:variance_p1} y \eqref{eq:variance_p2}.

        \begin{equation}
        \label{eq:variance}
          Var[\boldsymbol{X}] = \mathbb{E}[(\boldsymbol{X} - \mathbb{E}[\boldsymbol{X}])^2]
        \end{equation}

        \begin{equation}
        \label{eq:variance_p1}
          Var[\boldsymbol{X}] = \mathbb{E}[\boldsymbol{X}^2] - \mathbb{E}^2[\boldsymbol{X}]
        \end{equation}

        \begin{equation}
        \label{eq:variance_p2}
          Var[c\boldsymbol{X}] = c^2Var[\boldsymbol{X}]
        \end{equation}

        \paragraph{}
        A continuación se describe el concepto de \textbf{Independencia} entre dos variables aleatorias $\boldsymbol{X}, \boldsymbol{Y}$. Se dice que dos variables son independientes cuando los sucesos de cada una de ellas no están condicionados por los de otras. Esto puede verse a como el cumplimiento de la igualdad de la ecuación \eqref{eq:independence}.

        \begin{equation}
        \label{eq:independence}
          Pr[\boldsymbol{X} = x \cap \boldsymbol{Y} = y] = Pr[\boldsymbol{X} = x] \cdot Pr[\boldsymbol{Y} = y]
        \end{equation}

        \paragraph{}
        Cuando nos referimos al concepto de independencia referido a un conjunto $n$ variables aleatorias $\boldsymbol{X_1}, \boldsymbol{X_2},..., \boldsymbol{X_n}$ lo denominaremos \textbf{Independencia Mutua}, que impone la restricción descrita en la ecuación \eqref{eq:mutual_independence}.

        \begin{equation}
        \label{eq:mutual_independence}
          Pr \bigg[ \bigcap_{i=1}^n \boldsymbol{X_i} = x_i \bigg] = \prod_{i=1}^n Pr[\boldsymbol{X_i} = x_i]
        \end{equation}

        \paragraph{}
        También es de especial interés en el campo de los algoritmos probabilísticos el caso de la \textbf{k-independencia} sobre un conjunto de $n$ variables aleatorias $\boldsymbol{X_1}, \boldsymbol{X_2},..., \boldsymbol{X_n}$. Dicha idea se puede resumir como la independencia de todas las variables en grupos de $k$ variables. Este concepto tiene mucha importancia en el ámbito de los \emph{Sketches}, tal y como se verá en la sección \ref{sec:sketch}. El caso más simple es para $k = 2$, el cual se denomina \textbf{independencia pareada}, cuya modelización matemática se muestra en la ecuación \eqref{eq:pairwise_independence}.

        \begin{equation}
        \label{eq:pairwise_independence}
          \forall i, \forall j \ Pr[\boldsymbol{X_i} = x_i \cap \boldsymbol{X_j} = x_j] = Pr[\boldsymbol{X_i} = x_i] \cdot Pr[\boldsymbol{X_j} = x_j]
        \end{equation}

        \paragraph{}
        Desde el punto de vista de conjuntos de $n$ variables aleatorias  $\boldsymbol{X_1}, \boldsymbol{X_2},..., \boldsymbol{X_n}$, existen distintas propiedades de linearidad que se cumplen entre ellas a nivel del cálculo de la \emph{Esperanza} y la \emph{Varianza}. En el caso de la \emph{Esperanza}, la linealidad respecto de la suma (ecuación \eqref{eq:expectation_linearity}) se cumple para variables dependientes e independientes. Sin embargo, en el caso de la \emph{Varianza}, la linealidad respecto de la suma (ecuación \eqref{eq:variance_linearity}) se cumple tan solo para variables \textbf{independientes pareadas}.

        \begin{equation}
        \label{eq:expectation_linearity}
          \mathbb{E}\bigg[\sum_{i=1}^n \boldsymbol{X_i}\bigg] = \sum_{i=1}^n \mathbb{E}[\boldsymbol{X_i}]
        \end{equation}

        \begin{equation}
        \label{eq:variance_linearity}
          Var\bigg[\sum_{i=1}^n \boldsymbol{X_i}\bigg] = \sum_{i=1}^n Var[\boldsymbol{X_i}]
        \end{equation}

        \paragraph{}
        La \textbf{Probabilidad Condicionada} entre dos variables aleatorias $\boldsymbol{E_1}$ y $\boldsymbol{E_2}$ se puede definir como la medida de verosimilitud de la ocurrencia del suceso $\boldsymbol{E_1}$ sabiendo que ya ha ocurrido $\boldsymbol{E_2}$. Esto se puede modelizar matemáticamente tal y como se muestra en la ecuación \eqref{eq:conditional_probability}.

        \begin{equation}
        \label{eq:conditional_probability}
          Pr[\boldsymbol{E_1} \rvert \boldsymbol{E_2}] = \frac{Pr[\boldsymbol{E_1} \cap \boldsymbol{E_2}]}{Pr[\boldsymbol{E_1}]}
        \end{equation}

        \paragraph{}
        En el caso de la \textbf{Probabilidad Condicionada} sobre variables independientes, surge la propiedad descrita en la ecuación \eqref{eq:conditional_probability_independence}. Es fácil entender la razón, que se apoya en la idea de que si dos variables aleatorias no guardan relación, entonces la ocurrencia de una de ellas, no condicionará el resultado de la otra.


        \begin{equation}
        \label{eq:conditional_probability_independence}
          Pr[\boldsymbol{X_1} = x_1 \rvert \boldsymbol{X_2} = x_2] =
          \frac{Pr[\boldsymbol{X_1} = x_1 \cap  \boldsymbol{X_2} = x_2]}{Pr[\boldsymbol{X_1} = x_1]} =
          \frac{Pr[\boldsymbol{X_1} = x_1 \cdot \boldsymbol{X_2} = x_2]}{Pr[\boldsymbol{X_1} = x_1]} =
          Pr[\boldsymbol{X_2} = x_2]
        \end{equation}


        \paragraph{}
        Una vez descritos los conceptos estadísticos básicos para el análisis de algoritmos probabilísticos, lo siguiente es realizar una exposición acerca de las distintas cotas de concentración de valores, lo cual permite obtener resultados aproximados acerca de los resultados esperados por dichos algoritmos, así como sus niveles de complejidad. Primero se describirá \emph{Desigualdad de Boole}, para después tratar las desigualdades de \emph{Markov}(\ref{sec:markov_inequality}), \emph{Chebyshev}(\ref{sec:chebyshev_inequality}) y \emph{Chernoff}(\ref{sec:chernoff_inequality})

        \paragraph{}
        La \textbf{Desigualdad de Boole} consiste en una propiedad básica que indica que la probabilidad de que se cumpla la ocurrencia de un suceso es menor o igual que ocurrencia de la suma de todas ellas. Esto se modeliza matemáticamente en la ecuación \eqref{eq:boole_inequality}.

        \begin{equation}
        \label{eq:boole_inequality}
          Pr\bigg[\bigcup_{i=1}^n \boldsymbol{E_i}\bigg] \leq \sum_{i=1}^n Pr[\boldsymbol{E_i}]
        \end{equation}

      \subsection{Desigualdad de Markov}
      \label{sec:markov_inequality}

        \paragraph{}
        [TODO]

        \begin{equation}
        \label{eq:markov_inequality}
          \forall c > 0 \ Pr[\boldsymbol{X} \geq c \mathbb{E}[\boldsymbol{X}]] \leq \frac{1}{c}
        \end{equation}

      \subsection{Desigualdad de Chebyshev}
      \label{sec:chebyshev_inequality}

        \paragraph{}
        [TODO]

        \begin{equation}
        \label{eq:chebyshev_inequality}
          \forall c > 0 \ Pr[|\boldsymbol{X} - \mathbb{E}[\boldsymbol{X}]| \geq c \sqrt{Var[\boldsymbol{X}]}]  \leq \frac{1}{c^2}
        \end{equation}

      \subsection{Desigualdad de Chernoff}
      \label{sec:chernoff_inequality}

        \paragraph{}
        [TODO]

        \begin{equation}
        \label{eq:chernoff_inequality}
          \forall 0 < \delta < 1
        \end{equation}

    \section{Ejemplo Ilustrativo}
    \label{sec:streaming_puzzle}

      \paragraph{}
      [TODO ]


    \section{Algoritmo de Morris}
    \label{sec:streaming_morris_algorithm}

      \paragraph{}
      [TODO ]


    \section{Algoritmo de Flajolet-Martin}
    \label{sec:streaming_morris_algorithm}

      \paragraph{}
      [TODO ]


\end{document}
