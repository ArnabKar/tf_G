% !TEX root = ../../document.tex

\documentclass{subfiles}

\begin{document}

  \chapter{Implementación, Resultados y Trabajo Futuro}
  \label{chap:implementation}

    \section{Introducción}
    \label{sec:implementation_intro}

      \paragraph{}
      A lo largo de este documento se han descrito distintas ideas relacionadas con nuevas técnicas para tratar de hacer frente al problema de la complejidad derivada del tamaño de conjunto de datos de tamaño masivo, para el cual es necesario utilizar técnicas sofisticadas que agilicen dichos procedimientos. Dichos conceptos se han descrito desde una perspectiva teórica dejando de lado cuestiones de implementación u otros factores. Dicha abstracción ha permitido simplificar las descripciones teniendo en cuenta únicamente el enfoque algoritmico de las mismas.

      \paragraph{}
      Sin embargo, el enfoque que se seguirá en este capítulo pretende ser muy diferente, centrandose en los detalles de implementación y dejando de lado el contenido matemático. De esta manera, se pretende describir el código fuente desarrollado desde la perspectiva de su estructura y organización, ya que a pesar de basarse en una implementación que trata de ejemplificar conceptos descritos a lo largo del documento, se ha dedicado especial cuidado tratando de escribir código de calidad, mantenible y reutilizable.

      \paragraph{}
      Antes de profundizar en detalles relacionados con la implementación en si, es necesario realizar una explicación acerca de lo que se ha pretendido conseguir mediante el desarrollo de la misma, ya que debido al contexto en que se enmarca (\emph{Trabajo de Fin de Grado} de \emph{Ingeniería Informática}) y la metodología seguida para la realización  del mismo (\emph{Proyecto de Investigación}), esta implementación se encuentra en las primeras fases de su desarrollo, por lo cual aún no tiene el grado de madurez esperado para ser incluida en entornos de producción. A pesar de ello, se cree que la continuación en el desarrollo de la misma es una tarea interesante, que con las horas de trabajo necesarias, se podría convertir en una herramienta interesante frente a otras alternativas que existen actualmente.

      \paragraph{}
      Para entender lo que se ha pretendido conseguir con esta implementación, a continuación se ejemplifica un caso de una implementación similar que se ha llevado a cabo utilizando otras tecnologías en los últimos años. Dicha implementación (e ideas) se conoce como \emph{GraphX}, una biblioteca para el tratamiento de grafos masivos de manera distribuida presentada en \emph{2013} en el trabajo \emph{Graphx: A resilient distributed graph system on spark} \cite{xin2013graphx} desarrollado por \emph{Xin y otros}. Esta implementación se desarrolló inicialmente como un conjunto de utilidades y procedimientos sencillos para facilitar la representación de grafos y el desarrollo de algoritmos sobre estos.

      \paragraph{}
      \emph{GraphX} se ha desarrollado utilizando como base la plataforma de computación distribuida \emph{Spark} publicada en el trabajo \emph{Spark: Cluster computing with working sets} \cite{zaharia2010spark} de \emph{Zaharia y otros}. Esta plataforma se basa en el tratamiento de grandes conjuntos de datos mediante el procesamiento de los mismos en lotes, lo cual proporciona grandes mejoras respecto de otras soluciones como \emph{Hadoop}, presentado en el documento \emph{The hadoop distributed file system} \cite{shvachko2010hadoop} desarrollado por \emph{Shvachko y otros}.

      \paragraph{}
      Dichas plataformas tratan de abstraer la idea de procesamiento distribuido y hacerlo lo más transparente posible para el usuario, sin olvidar en ningún momento que los conjuntos de datos utilizados sobre los que se trabaja no se encuentran contenidos totalmente en una única máquina, lo cual implica distintas restricciones respecto de las estrategias de programación clásicas, como los procesos de acceso y escritura al sistema de almacenamiento. Sin embargo, en estos casos también existen soluciones que abstraen dichas tareas de almacenamiento distribuidas, algunas de ellas son \emph{Google File System} \cite{ghemawat2003google} o \emph{Hadoop File System} \cite{shvachko2010hadoop}.

      \paragraph{}
      Lo característico de \emph{GraphX} es que se ha desarrollado como una biblioteca para el tratamiento de grafos utilizando \emph{Spark} como plataforma base, pero tratando de mantener la independencia entre las mismas. Es decir, \emph{GraphX} ha sido desarrollado utilizando las utilidades que proporciona \emph{Spark}, pero en \emph{Spark} no existe ninguna dependencia hacia \emph{GraphX}. Por tanto, esto se puede entender como un sistema basado en capas, donde \emph{Spark} representa la capa inferior y \emph{GraphX} se coloca en una capa inmediatamente superior.

      \paragraph{}
      En este trabajo, se ha tratado de realizar una implementación semejante (a un nivel muy básico por las restricciones temporales en que se ha desarrollado), tratando de proporcionar igualmente una capa de abstracción que modeliza el concepto de grafo sobre otra plataforma de computación de alto rendimiento. En este caso se ha decidido utilizar la biblioteca de cálculo intensivo \emph{TensorFlow}, la cual se hizo pública en \emph{2016} en el trabajo \emph{Tensorflow: Large-scale machine learning on heterogeneous distributed systems} \cite{abadi2016tensorflow}, desarrollada por el departamente de investigación de \emph{Google} y actualmente publicada con licenciatura de código abierto.

      \paragraph{}
      \emph{TensorFlow} proporciona un \emph{framework} para la implementación de algoritmos cuyo funcionamiento se basa en el cálculo de operaciones sobre \emph{tensores} (una generalización del concepto de matriz). Se ha preferido posponer la descripción de esta plataforma hasta la sección \ref{sec:tensorflow}, ya que a continuación se describirá el conjunto de tecnologías utilizadas para la implementación realizada.

      \paragraph{}
      La motivación por la cual se ha decidido realizar la implementación de una biblioteca que simplifique el desarrollo de algoritmos sobre grafos utilizando una plataforma de cálculo matemático intensivo se debe a lo siguiente: una gran cantidad de analíticas sobre grafos pueden ser calculadas entendiendo dicho grafo como una estructura de datos matricial, a través de la \emph{matriz de adjacencia} (sección \ref{sec:adjacency_matrix}), u otras representaciones como la \emph{matriz laplaciana} (sección \ref{sec:laplacian_matrix}). Este marco conceptual conlleva el desarrollo de algoritmos con un alto grado de paralelización, que tal y como se verá posteriormete, satisface la plataforma \emph{TensorFlow}.

      \paragraph{}
      Sobre este contexto también se pueden desarrollar algoritmos de optimización, tales como planificación de rutas, recorridos de vehículos o cubrimiento de zonas mediante la modelización del grafo de manera conveniente y la utilización de distintas estrategias de programación lineal, lo cual se ha estudiado ampliamente en la literatura.

      \paragraph{}
      En este caso, la implementación realizada para este trabajo se encuentra en las primeras fases de su desarrollo. Por tanto, únicamente se ha basado en el conjunto de utilidades necesarias para llevar a cabo la implementación del \emph{Algoritmo PageRank} (capítulo \ref{chap:pagerank}), junto con un \emph{Sparsifier} (sección \ref{sec:sparsifiers}) que reduce el número de aristas del grafo para después comparar resultados a nivel de precisión.

      \paragraph{}
      Sin embargo, tal y como se indicará posteriormente, se pretende seguir trabajando en dicha biblioteca de grafos para ampliar su funcionalidad y desarrollar otras implementaciones que permitan obtener otras analíticas sobre el grafo.

      \paragraph{}
      El resto del capítulo se organiza de la siguiente manera: en la sección \ref{sec:implementation} se realiza una descripción acerca de las decisiones tomadas en la implementación de la biblioteca, indicando las tecnologías utilizadas (sección \ref{sec:used_technologies}), los servicios en que se ha apoyado el desarrollo (sección \ref{sec:used_services}) y el diseño que ha seguido dicha implementación (sección \ref{sec:implementation_design}). Posteriormente se realiza un comentario acerca de los resultados obtenidos en la sección \ref{sec:implementation_results}. A continuación se indican distintas vías a través de las cuales sería interesante seguir trabajando en la implementación en la sección \ref{sec:future_work} y, por último, se realiza una breve conclusión acerca del trabajo realizado en la sección \ref{sec:implementation_conclusions}

    \section{Implementación}
    \label{sec:implementation}

      \paragraph{}
      En esta sección se exponen distintas explicaciones acerca de la implementación realizada, la cual pretende comportarse como una biblioteca de utilidades que permita modelizar de manera sencilla el concepto de grafo, utilizando como base una plataforma de cálculo matemático intensivo. Dicha implementación se ha realizado prestando especial atención en la reducción de dependencias hacia el exterior, de tal manera que sea posible la distribución de la misma como un paquete compacto que integrar en otros sistemas de mayor envergadura. Por tanto, se ha utilizado el sistema de distribución de paquetes del lenguaje \emph{Python}, el cual simplifica dicha tarea. Sin embargo, antes de comenzar a describir distintos detalles acerca de las decisiones tomadas, a continuación se describen brevemente las tecnologias utilizadas, ya que son influyentes respecto de dichas decisiones.

      \subsection{Tecnologías Utilizadas}
      \label{sec:used_technologies}

        \paragraph{}
        La implementación se ha desarrollado utilizando el lenguaje \emph{Python}, junto con distintas bibliotecas que extienden su comportamiento y le otorgan una mayor funcionalidad. Además, se ha utilizado el sistema de control de versiones \emph{git}, que permite trabajar de manera ordenada en distintas partes del trabajo.

        \subsubsection{Python}
        \label{sec:python}

          \paragraph{}
          \emph{Python} se define como un lenguaje de propósito general sobre un paradigma imperativo pero con utilidades de programación funcional como funciones lambda o tratamiento de funciones como un valor más. Es orientado a objetos y no tipado, lo cual simplifica el trabajo a la hora de escribir código, pero limita la seguridad del mismo ante entradas incorrectas. Python es un lenguaje interpretado en tiempo de ejecución, por lo cual no es requiere de la utilización de un compilador. Internamente existen implementaciones de \emph{Python} en distintos lenguajes de programación compilados, sin embargo, en este caso el desarrollo se ha realizado sobre \emph{cpython}, que se basa en un itérprete desarrollado en el lenguaje \emph{C}.

          \paragraph{}
          En la revisión del estándar \emph{PEP-484} \url{https://www.python.org/dev/peps/pep-0484/} se añade un sistema de marcado de tipos para el lenguaje, el cual aún no está operativo en tiempo de ejecución (a través del intérprete), pero permite la comprobación estática del mismo. En la implementación realizado se ha utilizado este este sistema de comprobación de tipos, el cual se introdujo en \emph{Python 3.5}, por tanto está ha sido la versión escogida como mínima.

          \paragraph{}
          \emph{Python} implementa como estructura de datos indexadas \emph{listas enlazadas}, lo cual proporciona una gran versatilidad ya que permite tanto agregrar como eliminar nuevos elementos de manera eficiente ($O(1)$). Sin embargo, el tiempo de acceso se ve altamente penalizado por dicha condición ($O(n)$). Por tanto, se han utilizado bibliotecas externas que mejoran dichos costes.

        \subsubsection{NumPy y Pandas}
        \label{sec:numpy_pandas}

          \paragraph{}
          Para solventar la problemática de la eficiencia en tiempo de acceso de las estructuras de datos indexadas en \emph{Python} existe una biblioteca que permite implementa dichas estructuras de datos de manera contigua, lo cual elimina el problema. Dicha biblioteca se conoce como \emph{NumPy} \cite{walt2011numpy}, la cual proporciona además un gran conjunto de operaciones matemáticas sobre esta estructura de datos. De esta manera se permite desarrollar algoritmos con una elevada carga matemática de manera muy eficiente y a la vez sencilla, al estilo de lenguajes como \emph{MatLab} o \emph{R}.

          \paragraph{}
          Para algunas partes del código implementado, se ha utilizado la biblioteca \emph{Pandas} \cite{mckinney2010data}. Esta biblioteca consiste en una extensión respecto de \emph{NumPy}, que permite ver la estructura de datos desde una perspectiva de conjunto de datos en lugar de estructura matemática, lo cual simplifica el trabajo para tareas como la lectura y estructa de conjuntos de datos en el espacio de almacenamiento.

        \subsubsection{TensorFlow}
        \label{sec:tensorflow}

          \paragraph{}
          [TODO ] \emph{TensorFlow} \cite{abadi2016tensorflow}

        \subsubsection{pytest}
        \label{sec:tensorflow}

          \paragraph{}
          \emph{pytest} es una herramienta de generación de casos de prueba para el lenguaje \emph{Python}. Para ello se basa en la ejecución de distintas funciones definidas por el usuario, las cuales contienen un conjunto de asertos (palabra reservada \emph{assert} en \emph{Python}), los cuales deben superar satisfactoriamente para finalizar el test de manera satisfactoria. Para los casos de prueba, estos se han utilizado junto con los que proporciona \emph{NumPy} para comprobar la semejanza entre dichas estructuras de datos de manera eficiente.

        \subsubsection{sphinx}
        \label{sec:sphinx}

          \paragraph{}
          \emph{sphinx} consiste en una herramienta que permite extraer la documentación incorporada en el código a otras fuentes para facilitar su visualización, tales como un sitio web, documentos de \emph{PDF} y otras alternativas. Para ello se basa en la documentación interna del código. En el caso de \emph{Python}, esta documentación se denomina \emph{docstring} y permite añadir una breve explicación acerca de los bloques de código, así como las entradas y salidas de los métodos. En este caso se ha utilizado el estilo de documentación definido por \emph{Google} para tratar de asemejarse lo máximo posible a la documentación seguida por \emph{TensorFlow}

        \subsubsection{git}
        \label{sec:git}

          \paragraph{}
          \emph{git} se corresponde con un \emph{sistema de control de versiones} que permite el trabajo de manera colaborativa entre distintos usuarios, a través de distintas ramas de desarrollo, que después se combinan para llegar a un estado de desarrollo final. Además de esto, permite almacenar un historial de todos los cambios realizados, lo cual es de gran ayuda en puntos en los cuales es necesario entender la razón de cambios pasados así, como retroceder hasta un estado anterior si fuera conveniente. Otra de las ventajas de esta herramienta es la capacidad de sincronización entre distintos sistemas, así como la posibilidad de mantener una copia del repositorio en un servidor externo, lo cual previene de problemas relacionados con fallos del sistema local.

      \subsection{Servicios Utilizados}
      \label{sec:used_services}

        \paragraph{}
        [TODO ]

        \paragraph{GitHub}
        [TODO ]

        \paragraph{Read the Docs}
        [TODO ]

        \paragraph{Travis CI}
        [TODO ]

        \paragraph{Codecov}
        [TODO ]

      \subsection{Diseño de la implementación}
      \label{sec:implementation_design}

        \paragraph{}
        [TODO ]

      \paragraph{}
      [TODO]

    \section{Resultados}
    \label{sec:implementation_results}

      \paragraph{}
      [TODO]

    \section{Trabajo Futuro}
    \label{sec:future_work}

      \paragraph{}
      [TODO]

    \section{Conclusiones}
    \label{sec:implementation_conclusions}

      \paragraph{}
      [TODO]

\end{document}
